# 类型和函数

类型和函数的范畴在编程中扮演着重要的角色，让我来谈谈类型是什么以及为我们为什么需要它。

# 谁需要类型

大家似乎对应该选择静态类型还是动态类型、强类型还是弱类型有争议，让我们通过一个思维实验来进行一番论述。假设有成千上万的猴子在电脑键盘前愉快地胡乱敲打，编写代码、编译、运行。

对于机器语言，猴子敲击的任何指令都将被接收并运行；但是对于高级语言，我们得由衷感谢编译器替我们检测出词法和语法错误。大部分猴子会因为没有香蕉而离开，而剩下的程序更有可能是有效的。此外，对于动态类型语言，类型不匹配将会留到运行时才能发现；而对于强类型的静态语言，类型不匹配可以在编译时就发现，降低了在运行时产生大量错误的可能性。

所以问题在于我们希望猴子保持快乐，还是希望得到正确的程序。

打字猴思维实验中的目标通常是制作莎士比亚全集。有一个持续循环工作的拼写检查和语法检查，能极大提高完成的可能性。类似的类型检查器则会更进一步确保一旦罗密欧被宣布为人类，他就不会在他强大的引力场中发芽或捕获光子。

# 类型是可组合的

范畴论就是讨论箭头的组合，但并不是任意两个箭头都可以组合。一个箭头的目标对象必须和下一个箭头的原对象一致，才能组合。在编程语言中，我们将一个函数的结果传入给另一个函数，如果目标函数无法正确理解源函数产生的数据，程序将无法正常工作。二者必须匹配组合的要求才能工作。越是强类型的语言系统，这种匹配就越能被描述和严格地证明。

对于强静态类型检查我听到的唯一地严肃争论是它可能会消灭一些语义上是正确的程序。实际上，这种情况及其罕见，而且不管怎样，每种编程语言都会在必要的时候提供一些后门去绕过类型系统。甚至Haskell都有 `unsafeCoerce`。但是对于这种设备应该谨慎使用，在Franz Kafka的书中，Gregor Samsa打破类型系统变身成为一个巨大的飞虫，最后的结局我们都知道

另一个我常听说的争论是类型处理给程序员带来了太多负担。对这种情绪我表示同情，我自己使用C++时不得不写一些迭代器的声明，我希望有一种技术称之为类型推断来让编译器根据上下文自行判断所使用对象的类型。现在在C++中，你可以使用 `auto` 关键字声明变量，让编译器自动失败其类型。

在Haskell中，除了很少的使用场景外，类型注记完全是可选的。无论如何，程序员们倾向于使用它，因为这可以提供更多的代码语义，也使得在编译出错时更容易理解。在Haskell中，通过设计类型来启动一个项目是一个常见的做法。后来，类型注记驱动着实现，也称为编译器强制注释。强静态类型经常成为不进行代码测试的借口，你可能听Haskell程序员们说过：“只要编译成功，就不会出错”。当然，类型正确的程序并不能保证是产生正确输出的意义上的的正确程序。这种漫不经心的态度的结果就是在一些研究中Haskell并没有像人们意料的一样在代码质量方面有突出的表现。似乎在商业环境中，修复Bug的压力取决于特定的质量等级，这与软件开发的经济性和最终用户的容忍度有关，和编程语言方法论基本没有关系。一个更好的准则会衡量有多少项目落后进度，或者交付时功能缩水多少。

至于些观点认为单元测试可以取代强类型，考虑强类型语言的一般重构：改变某特定函数的参数类型。对于强类型语言，改变函数的声明然后修复编译错误就行了。而在对于弱类型语言，一个函数期望不会有不同的数据传入调用点。单元测试可能会捕获一部分不匹配，但测试终究是尽可能地验证，并不完全可靠。测试是证明的不可靠替代。

# 什么是类型？

对于类型的直觉认识就是一堆值的集合。 `Bool` 类型（在Haskell中类型首字母大写）是两个元素的集合， `True` 和 `False` 。 `Char` 是所有Unicode字符的集合，像’a’ 或者'ą’。

集合可以是有限的也可以是无限的， `String` 类型，即 `Char` 列表同义表示，是典型的无限集合

当我们声明 `x` 为 `Integer` :

```haskell
x :: Integer
```

我们说这是一个整数集合中的一个元素， `Integer` 在Haskell中是一个无限集合，可以用于任意精度的算术运算。Haskell也有有限集合 `Int` 取决于机器类型，就像C++的 `int` 。

有些微妙之处使得这种类型定义和集合的识别变得棘手起来，问题在于多态函数会引入循环定义，问题是你并没有所有集合的集合，就像我承诺的，我不想陷入数学的讨论中。很棒地是可以用 `Set` 可以表示集合的范畴，可以很好地解决我们的问题， `Set` 中的对象是集合，态射（箭头）是函数。

`Set` 是非常特别的范畴，因为我们实际上可以窥探它的对象，并从中获得很多直觉的认识。例如，空集没有元素；存在只有一个元素的集合；一个集合的元素态射到另一个集合的某个元素；两个元素可以态射到一个，而不是一个元素态射到两个；单位函数将每一个元素映射到元素自身，等。打算逐渐忘记这些信息，而用纯粹的范畴术语即对象和箭头来表达所有这些概念。

在理想世界中，我们认为Haskell中的类型是集合，Haskell中的函数是数学意义上的关于集合的函数。这儿有个小问题：一个数学意义的函数不会执行任何代码就可知道答案。一个Haskell函数必须要经过计算才能得到答案。如果经过有限步骤，不管需要的步骤是多么大的一个数目，可以计算出答案，这也不是问题。但是有些计算涉及到递归，可能永远也不会终止。我们没办法禁止使用不会终止的Haskell函数，因为函数是否会终止这是不可预料的，即著名的宕机问题。这就是为什么计算机科学家提出了一个天才想法，还是说巨大的hack，取决于你的看法，扩展每一个类型添加一个额外的值叫做bottom，表示为`_|_` 或者Unicode表示为⊥。这个 “值” 表示一个非终止的计算。所以像这样的函数声明：

```haskell
f :: Bool -> Bool
```

可能返回 `True` ， `False` ， 或者 `_|_` ；后者表示它将永远不会停止。

有意思地是，一旦你接受bottom作为类型系统的一部分，那么可以很方便地将所有运行时错误当作一个bottom，甚至允许函数现实地返回bottom。后者通常用 `undefined` 表达式来表示，像这样：

```haskell
f :: Bool -> Bool
f x = undefined
```

这个定义是合法的，因为 `undefined` 计算的结果是bottom，它可以表示任意类型，包括 `Bool` .甚至可以这样写：

```haskell
f :: Bool -> Bool
f = undefined
```

（没有写x）因为bottom也是类型 `Bool->Bool` 的成员。

可能返回bottom的函数称之为部分地，与完全地函数相反，它针对任何可能的参数返回有效的结果。

由于bottom的存在，你将会注意到Haskell类型和函数的范畴被称之为 `Hask` 而不是 `Set` 。从理论的角度看，这是永不停止并发症的源头，所以在这一点上，我将用屠刀终止这种推理。从编程的角度看，可以忽略非终止函数和bottom，并将 `Hask` 当作真正的 `Set` （见最后参考书目）。

# 为什么我们需要一个数学模型？

作为一个程序员，你会对自己的语言的语法感到亲切地熟悉。语言的语法概念通常在语言规范的开头用形式化的符号描述。但是一个语言表达的意思或者语义很难去描述，这需要写很多页，几乎很难足够规范地表述，几乎也不大可能完整。因此语言律师总是无休止地争吵，各种书籍通篇都致力于解释语言标准的细微之处。

有一些形式化工具可以描述语言的语义，但由于其复杂性，几乎只在简单的学术性语言中使用。一种称之为操作语义的工具描述了程序执行的机制，它定义了一个形式化的理想化的解释器。工业语言（如C++）的语义，通常使用非形式化操作推理来描述，通常表示为术语 “抽象机器”。

问题是用操作语义很难证明和程序相关的事物，要展示程序的属性，你必须通过理想化的解释器 “运行” 它。

程序员从不形式化证明程序的正确性，这并不重要。我们总是“认为” 我们写的程序是正确的，没有人会坐在在键盘前，说：“我将丢弃几行代码，看看会发生什么”。我们认为我们写的代码将会执行特定的动作，并产生想要的结果。如果它没有，我们通常会感到惊讶。这意味着我们对编写的程序进行了某种意义的推理，通常我们在大脑里面像解释器一样运行写的代码，这很难追踪所有变量。计算机很擅长运行程序——而不是人类，要不然，我们也不需要电脑了。

但是还有一个选择。它称之为指称语义，这是基于数学的一个术语。在指称语义里，每个可编程的构造都给出了数学的定义，通过这个，如果你像证明一个程序的某个属性，你仅需证明一个数学定理即可。你可能会认为定理的证明是困难的，但事实上人类几千年来一直在加强构建数学方法，所以有丰富的已经累积的知识可以利用。再者，相对于专业的数学定理的证明，我们在编程中遇到的问题即使不是微不足道的，通常也是非常简单的。

考虑Haskell中阶乘函数的定义，Haskell是一种非常符合指称语义定义的语言：

```haskell
fact n = product [1..n]
```

表达式 `[1..n]` 表示从1到n的整数列表。函数 `product` 将列表的所有元素相乘。和数学意义上阶乘定义很像。对比C语言的定义：

```c
int fact(int n) {
    int i;
    int result = 1;
    for (i = 2; i <= n; ++i)
        result *= i;
    return result;
}
```

还需要我多说吗？

好吧，首先必须承认Haskell的表达相当简洁！一个阶乘函数拥有明显的数学表示，聪明的读者可能会问：有什么数学模型能表示从键盘读取一个字符或者通过网络发送一个数据包呢？长时间以来，这都是一个尴尬的问题导致一个相当复杂的解释。似乎指称语义并不是最适合编写需要处理大量任务的有用程序，而这些则很适合通过操作语义解决。突破来自范畴论，Eugenio Moggi 发现计算结果可以映射到单子。事实证明，这是个重要观察结果，它不仅赋予指称语义新的声明，并使纯函数式语言更有用，但也为传统编程提供了新的视角。稍后当我们开发更多范畴工具时，将讨论单子。

构建数学模型的一个优点就是可以对程序进行形式化证明其正确性。当你开发消费者软件时，这可能不重要；但是在某些领域的编程，错误的代价是昂贵的，或者在危及生命的地方。但即使是在编写关于健康系统的网页应用，你可能也会欣赏Haskell标准库中函数和算法带有正确性证明的想法。

# 纯函数和脏函数

对于C++或者任何命令式编程语言的函数，和数学意义上的函数并不是一回事。一个数学意义上的函数就是值到值的映射。

我们可以在编程语言中实现数学意义的函数：定义一个这样的函数，给一个输入值将会计算产生一个输出值。一个计算平方的函数，可能会将输入与输入相乘。每次调用，都会那样执行，并且保证对于每一个同样的输入产生同样的输出。一个数字的平方不会随着月相的变化而变化。

当然，计算一个数的平方不应该对为你的狗分配食物产生副作用。一个不能轻易建模为数学意义函数的“函数”

在编程语言中，在给定相同的输入产生相同结果并且没有副作用的函数称之为纯函数。在纯函数式语言像Haskell，所有函数都是纯的。由于这一点，更容易给出这些语言的指称语义，并为其通过范畴论建立数学模型。而对于其他的语言，总是可以将自己限制在一个纯子集内，或者单独推理副作用。稍后将看到monad是如何让我们仅使用纯函数来模拟各种效果，所以我们真的不会因为把自己限制在数学函数上而失去任何东西。

# 类型的例子

一旦你认识到类型就是集合，你可以考虑一些非常奇异的类型。例如，什么类型表示空集？不，当然不是C++的 `void` ，虽然这个类型在Haskell中称为 `Void` 。这个类型不持有任何值，你可以定一个函数接受 `Void` 类型的参数，但是你将永远不能调用它。如果要调用它，你必须传一个 `Void` 类型的值，但是它并不是C++中表示任何类型的意思。至于这个函数可以返回什么，这倒没有什么限制。它可以返回任何类型（虽然这不可能，因为它不会被调用）。换句话说，它是一个返回多态类型的函数，这个函数有一个名字：

```haskell
absurd :: Void -> a
```

（注意， `a` 是一个类型变量，可以代表任何类型。）这个名字并非巧合，在逻辑方面对类型和函数有更深入的解释，称之为Curry-Howard 同构。 `Void` 类型代表虚假，而函数 `absurd` 表示从虚假跟随任何事物的陈述，如拉丁格言“ex falso sequitur quodlibet.”。

下面考虑单例集的类型，即只有一个可能值的类型。这个值只是“是”。你可能不会立即认出它，那是因为那是C++的 `void` 。想想这种类型的函数，它总是调用来自 `void` 的函数，如果它是一个纯函数，它总是返回相同的结果。函数示例如下：

```c
int f44() { return 44; }
```

你可能认为这个输入为空，但是就像已经看到的，一个函数接受“空”永远也不可能被调用，因为没有值可以表示为“空”。所以这个函数输入是什么？在概念上，它接受只有一个实例的虚拟值，因此我们不必明确提及它。然而在Haskell中，有一个符号可以表示该值：一对括号 `()` 。所以，通过这个有趣的巧合（或者真实巧合吗？），这和C++中调用一个输入为空函数很像。同样地，由于Haskell喜欢简洁性，同样的符号 `()` 也可以表示类型，构造器，以及表示单集中的唯一值。所以在Haskell中存在这样的函数：

```haskell
f44 :: () -> Integer
f44 () = 44
```

第一行声明 `f44` 接受类型为 `()` , 读作’unit’，产生类型为 `Interger` 。第二行通过模式匹配来定义 `f44` 仅是 unit构造器，产生结果44。通过传递unit类型值 `()` 可以调用这个函数：

```haskell
f44()
```

请注意，unit的每个函数相当于从目标类型中选择一个元素（这里选择整数44）。事实上你可以将函数 `f44` 当成数字44的另一种表达。这是一个示例，说明我们如何通过讨论函数（箭头）来代替集合元素的明确提及。从unit到任何类型A的函数都与该集合A的元素一一对应。

那么具有 `void` 返回类型的函数，或者在Haskell中具有unit返回类型的函数呢？在C++中，这种函数用于产生副作用，但我们知道这不是数学意义上的函数。一个纯函数返回unit类型，将什么都不做：直接丢弃所有参数。

数学上，一个函数从一个集合A到单例集合，将映射集合A中的每一个元素到单利集中的单一元素。对于每一个集合A，都只有一个这样的函数。这是 `Integer` 集合的函数：

```haskell
fInt :: Integer -> ()
fInt x = ()
```

你可以传入任何整数，都将返回一个unit。本着对简洁性的追求，Haskell允许你使用通配符模式，即下划线_，表示不被考虑的参数。这种方式下，你不必给它发明一个名字，所以可以改写成：

```haskell
fInt :: Integer -> ()
fInt _ = ()
```

注意，这个实现不仅不关心我们传的值，甚至也不关心传递的参数类型。

任何类型都可以用相同公式实现的函数，称之为参数多态。你可以通过类型参数用一个等式实现一整个家族的这样的函数，而不是使用具体的类型。我们应该怎样称呼从任何类型到unit类型的多态函数？当然我们称它为unit:

```haskell
unit :: a -> ()
unit _ = ()
```

在C++中你可能这样定义这个函数：

```cpp
template<class T>
void unit(T) {}
```

下面来讨论类型学中两个元素集合，在C++中称之为 `bool` 在Haskell中，可预见地，称为 `Bool` 。不同之处是C++中， `bool` 是内建类型，而在Haskell中，可以定义如下：

```haskell
data Bool = True | False
```

（阅读方式：定义 `Bool` 为 `True` 或者 `False` ）原则上，也可以在C++中将布尔类型定义为枚举：

```cpp
enum bool {
  true,
  false
};
```

但是C++的枚举实际上就是整形。C++11 的 枚举类 可以用来代替，但是必须限定类名，如   bool::true 和bool::fasle，更不必说需要在使用的地方正确地包含头文件。

接受`Bool` 的纯函数，只需从目标类型中选择两个值，一个对应于 `True` ，另一个对应 `False` 。

返回 `Bool` 的函数称之为谓词，例如Haskell 库Data.Char充满了诸如isAlpha 或者isDigit之类的谓词。在 C++ 中有一个类似的库，其中定义了 isalpha 和 isdigit，但它们返回的是 int 而不是 Boolean。实际谓词在 std::ctype 中定义，形式为 ctype::is(alpha, c)、ctype::is(digit, c) 等。

# 挑战

1. 用你喜欢的语言定义一个高阶函数（或函数对象） `memoize`。这个函数接受一个纯函数 `f` 作为参数，并返回一个行为几乎与 `f` 完全一样的函数，除了它只为每个参数调用一次原始函数，在内部存储结果，然后每次使用相同的参数调用它时都返回这个存储的结果。你可以通过观察它的表现来区分记忆功能和原始功能。例如，尝试记住一个需要很长时间才能评估的函数。第一次调用时你必须等待结果，但在随后的调用中，使用相同的参数，你应该立即得到结果。
2. 试着从你的标准库中记住一个你通常用来产生随机数的函数。它有效吗？
3. 大多数随机数生成器都可以使用种子进行初始化。实现一个函数，该函数接受一个种子，使用该种子调用随机数生成器，然后返回结果。记住该功能。它有效吗？
4. 这些 C++ 函数中哪些是纯函数？尝试记住它们并观察当你多次调用它们时会发生什么：记录或者什么都没发生。
    1. 本文示例中的阶乘函数。
    2. `std::getchar()`
    3. `bool f() { std::cout << "Hello!" << std::endl; return true;
    }`
    4. `int f(int x)
    { static int y = 0; y += x; return y;
    }`
5. 从 `Bool` 到 `Bool` 有多少种不同的函数？你能全部实现吗？
6. 绘制一个类别的图，该类别的唯一对象是 `Void`、`()`（unit）和 `Bool` 类型；带有对应于这些类型之间所有可能功能的箭头。用函数的名称标记箭头。

# 参考

1. Nils Anders Danielsson, John Hughes, Patrik Jansson, Jeremy Gibbons, [Fast and Loose Reasoning is Morally Correct](http://www.cs.ox.ac.uk/jeremy.gibbons/publications/fast+loose.pdf). This paper provides justification for ignoring bottoms in most contexts.