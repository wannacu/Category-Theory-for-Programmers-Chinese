# 序

> “ 一段时间以来，我一直想写一本面向程序员的关于范畴论的书。注意，不是面向计算机科学家而是程序员——工程师而不是科学家。我知道这听起来有点疯狂，自己都有点害怕。因为我曾经在两边都工作过，我很清楚科学和工程二者的巨大鸿沟。但是我一直有阐释技术原理的强烈冲动。我非常崇拜理查德.费曼，他很擅长将对复杂的问题作出简单易懂的解释。当然我不是费曼，但是我会尽力做到最好。我以发布这篇序作为开端，推动读者学习讨论范畴论，以及听取大家的反馈。”
>

&emsp;&emsp;我将尝试用几段话说服你，这本书就是为你写的，无论你会对拿出“丰富的业余时间”去学习最抽象的数学分支犯什么嘀咕，都是完全站不住脚的（质疑）。

&emsp;&emsp;我的乐观基于以下几个观察。

&emsp;&emsp;第一，范畴论是极其有用的编程思想宝藏。Haskell 程序员长期以来一直在挖掘这块宝藏，并将编程思想渗透到其他语言，只是进展太慢了，我们需要加快速度。

&emsp;&emsp;第二，数学有不同的分支，吸引着不同的受众。或许你极其讨厌微积分或代数，但也不妨碍你喜欢范畴论。我始终认为范畴论一门特别适合程序员头脑的数学，因为范畴论关注结构而不关注细节，这一特性使得程序可进行组合。

&emsp;&emsp;组合是范畴论的根本——它是范畴本身定义的一部分。我强烈主张组合是编程的本质。早在某个伟大的工程师提出子程序前，我们便一直在进行组合编程。之前的一段时间，结构化编程由于代码块可以进行组合而一度革新了编程，之后便是面向对象的编程，完全是关于组合对象的。函数式不仅是关于组合函数和代数数据结构——还可以使并发进行组合——这在其他编程范式中几乎是不可能的。

&emsp;&emsp;第三，我有个秘密武器，一把屠刀，我会将数学分解成适合程序员的美味。当你是一名专业的数学家时，你必须非常小心地明晰所有假设，正确地限定每句陈述，并严格地构建你的所有证明。这使得数学论文和书籍对外行人非常难读。我是一名受过训练的物理学家，在物理学中，我们利用非形式推理取得了惊人的进步。数学家门嘲笑的狄拉克$δ$函数，是伟大的物理学家P.A.M.狄拉克为了求解一些微分方程临场编造出来的。当数学家们发现一个全新的微积分分支，称为分布理论，它形式化了狄拉克的见解后，他们停止了嘲笑。

&emsp;&emsp;诚然，使用大而化之的论证时，你会冒着说胡话的风险，所以我会尽量确保本书中非形式论证背后有坚实的数学理论作支撑。我确实在床头柜上放有一本磨破皮的Saunders Mac Lane著作*Category Theory for the Working Mathematician。*

&emsp;&emsp;由于这是写给程序员的范畴论，所以我会使用代码来阐述主要概念。你可能意识到相较于更加流行的命令式语言，函数式语言更加接近数学语言。函数式语言也更加具有抽象的能力。所以一个自然的想法会涌向心头告诉你：你必须学习Haskell，才能消化的范畴论这一宝藏。这就意味着范畴论在除函数式编程外没有任何应用，但这是根本错误的观念。所以我会提供大量的C++例子，当然，你得克服一些难看的语法，这些模式不会从冗长的背景脱颖而出，并且你可能不得不进行一些代码拷贝而不是抽象，这就是C++程序员的日常。

&emsp;&emsp;但就Haskell而言，你并没有摆脱困境。你不必称为一名Haskell程序员，但是你需要将它作为一种语言来绘制和记录要在C++中实现的想法。这恰恰是我开始使用Haskell的方式，我发现它简单的语法和强大的类型系统对理解C++模版、数据结构和算法大有裨益。但由于我不能指望读者已经熟悉Haskell了，所以我会慢慢介绍它，在用到的时候详细解释。

&emsp;&emsp;如果你是一名经验丰富的程序员，可能会自问：我编程这么多年，从未关心过范畴论或者函数式方法，难道编程世界发生了什么变化了吗？当然你肯定注意到了源源不断的函数式特性入侵了命令式语言。即使是面向对象编程的桥头堡Java，也让C++中的lambda匿名函数最近以疯狂的速度发展——每隔几年就会有个新标准——试图赶上不断变化的世界。所有这些活动都在为破坏式变化作准备，或者以我们物理学家的说法称之为相变。如果你持续加热，水最终会沸腾。我们现在就像温水中青蛙，要么继续在越来越热的水中游泳，要么寻找替代方案。

<div align=center>
<img src="img/img_1299.jpg"/>
</div>

&emsp;&emsp;多核革命是推动这一巨大变革的力量之一。流行的编程范式，面向对象编程，在并发和并行领域占不到任何便宜，反而会促使危险和错误的设计。数据隐藏是面向对象的基本前提，当于共享和可变结合时，便成了数据竞争的万恶之源。将互斥锁和要保护的数据相结合的想法很好，但不幸地是，锁不能组合，隐藏锁更容易发生死锁且难以调试。

&emsp;&emsp;但就算在非并发的情况下，软件系统日益增长的复杂性也在考验着命令式范式的可伸缩性极限。简而言之，命令式范式的副作用（译者注：编程中函数或表达式副作用指函数或表达式修改不属于自自身范围外的状态）正如脱缰之野马。确实，命令式语言的函数通常简单且易于编写，原则上它们的作用可以函数命名表达，一个名为 SetPassword 或 WriteFile 的函数很明显其功能就是修改某些状态产生某些副作用，我们习惯了这样的编程范式。只有当我们开始在具有副作用的其他函数上编写具有副作用的函数时，事情才开始变得棘手起来。并不是说副作用天然地不好——而是而是它们隐藏在视线之外，使得它们在大规模程序中无法管理。副作用不可扩展，命令式编程语言全都是有副作用的。

&emsp;&emsp;硬件的革新和软件日益增长的规模迫使我们重新思考编程的基石。我们就像欧洲哥特式城堡的建造者，将自己的手艺打磨到利用已有材料和结构的极限。法国博韦有一座未完工的哥特式大教堂，它见证了人类与局限性的深刻斗争。它原本打算打破之前所有的高度及轻量化的记录，却屡次倒塌。金属和木支架等临时支护使其避免了解体，但显然其内部出现了很多问题。以现在的视角来看，在没有现代材料学、计算机建模、有限元分析以及一般数学和物理学知识的帮助下能建成如此多的哥特式建筑简直就是一个奇迹。我希望未来几代人也会这样钦佩我们在构建复杂操作系统、Web服务器和互联网基础设施方面所展现的编程技能。坦白地说，我们值得他们的钦佩，因为我们所完成的都是基于非常脆弱的理论基础。如果我们想前进，我们必须修复这些基础。
<div align=center>
<img src="img/beauvais_interior_supports.jpg"/>
</div>
